"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var r=require("crypto");const e=require("cbor"),t=require("bip39");let n;const o=async()=>class{static async load(){return n||(n=await Promise.resolve().then((function(){return require("./cardano_serialization_lib.js")})),n)}}.load();async function i(r,t){const n=e.encode({...r}),o=await p(n,t);return`${n.toString("hex")}.${o.to_hex()}`}async function s(r,t){const{Ed25519Signature:n}=await o(),[i,s]=r.split("."),a=Buffer.from(i,"hex"),f=n.from_hex(s);if(!await y(a,t,f))throw new Error("Verification failed");return e.decode(a)}async function a(r){const{Bip32PrivateKey:e}=await o(),n=Buffer.from(t.mnemonicToEntropy(r),"hex");return e.from_bip39_entropy(n,Buffer.from("")).to_raw_key()}async function f(e,t){const n=await o(),i=r.createHash("sha256").update(`wallet:mnemonic:${t}`).digest("hex"),s=r.randomBytes(12).toString("hex"),a=Buffer.from(JSON.stringify(e)).toString("hex"),f=Buffer.from(t).toString("hex");return n.encrypt_with_password(f,i,s,a)}async function c(r,e){const t=await o(),n=Buffer.from(e).toString("hex"),i=t.decrypt_with_password(n,r);return JSON.parse(Buffer.from(i,"hex").toString())}async function u(e){const t=r.randomBytes(3).readUIntLE(0,3)>>>4,n=t;return t<1e6?`${n}`.toString():void 0===e?`${await u(`${n}`)}`.toString():`${Math.abs(n-parseInt(e))}`.toString()}async function p(r,e){const t=Buffer.from(r);return e.sign(t)}async function y(r,e,t){const n=Buffer.from(r);return e.verify(n,t)}var d={expose:o,mnemonicToRootKeyPair:a,encryptWithPin:f,decryptWithPin:c,randomPin:u,signBuffer:p,verifyBuffer:y,issueJWTCborToken:i,verifyJWTCborToken:s};exports.decryptWithPin=c,exports.default=d,exports.encryptWithPin=f,exports.expose=o,exports.issueJWTCborToken=i,exports.mnemonicToRootKeyPair=a,exports.randomPin=u,exports.signBuffer=p,exports.verifyBuffer=y,exports.verifyJWTCborToken=s;
