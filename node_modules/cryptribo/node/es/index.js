import{createHash as r,randomBytes as t}from"crypto";const n=require("cbor"),e=require("bip39");let o;const i=async()=>class{static async load(){return o||(o=await import("./cardano_serialization_lib.js"),o)}}.load();async function a(r,t){const e=n.encode({...r}),o=await m(e,t);return`${e.toString("hex")}.${o.to_hex()}`}async function f(r,t){const{Ed25519Signature:e}=await i(),[o,a]=r.split("."),f=Buffer.from(o,"hex"),c=e.from_hex(a);if(!await p(f,t,c))throw new Error("Verification failed");return n.decode(f)}async function c(r){const{Bip32PrivateKey:t}=await i(),n=Buffer.from(e.mnemonicToEntropy(r),"hex");return t.from_bip39_entropy(n,Buffer.from("")).to_raw_key()}async function s(n,e){const o=await i(),a=r("sha256").update(`wallet:mnemonic:${e}`).digest("hex"),f=t(12).toString("hex"),c=Buffer.from(JSON.stringify(n)).toString("hex"),s=Buffer.from(e).toString("hex");return o.encrypt_with_password(s,a,f,c)}async function u(r,t){const n=await i(),e=Buffer.from(t).toString("hex"),o=n.decrypt_with_password(e,r);return JSON.parse(Buffer.from(o,"hex").toString())}async function y(r){const n=t(3).readUIntLE(0,3)>>>4,e=n;return n<1e6?`${e}`.toString():void 0===r?`${await y(`${e}`)}`.toString():`${Math.abs(e-parseInt(r))}`.toString()}async function m(r,t){const n=Buffer.from(r);return t.sign(n)}async function p(r,t,n){const e=Buffer.from(r);return t.verify(e,n)}var d={expose:i,mnemonicToRootKeyPair:c,encryptWithPin:s,decryptWithPin:u,randomPin:y,signBuffer:m,verifyBuffer:p,issueJWTCborToken:a,verifyJWTCborToken:f};export{u as decryptWithPin,d as default,s as encryptWithPin,i as expose,a as issueJWTCborToken,c as mnemonicToRootKeyPair,y as randomPin,m as signBuffer,p as verifyBuffer,f as verifyJWTCborToken};
